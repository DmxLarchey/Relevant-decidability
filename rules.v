(**************************************************************)
(*   Copyright Dominique Larchey-Wendling [*]                 *)
(*                                                            *)
(*                             [*] Affiliation LORIA -- CNRS  *)
(**************************************************************)
(*      This file is distributed under the terms of the       *)
(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)
(**************************************************************)

Require Import List.

Require Import list_utils finite.

Set Implicit Arguments.

Section representation_of_rules.

  (* Representation of rules generated by a type of instances *)
  
  Variable (X : Type) (eqX_dec : forall x y : X, { x = y } + { x <> y} ).
  
  (** A rule is a relation between conclusions and lists of premises denoted
  
                    H1 .... Hn
                    ----------
                        C
                        
  *)
  
  Variables (r : X -> list X -> Prop).
  
  (** A representation for a rule is a map from a type a parameters
      to instances a rules
      
                  H1(i) .... Hn(i)
                  ----------------
                        C(i)
                        
  *)
  
  Variables (I : Type) (f : I -> X * list X).
  
  (* Every parameter gives a instance of the rule *)

  Definition soundly_represents := 
    forall i, match f i with (c,hs) => r c hs end.
    
  (* for any given conclusion C, there is a finite set of parameters 
     (represented by a list) such that any rule instance with conclusion C 
     belongs to the image of this finite set of parameters *) 

  Definition finitely_represents :=
    forall c, { ll | forall hs, r c hs <-> exists i, f i = (c,hs) /\ In i ll }.
    
  (* soundly and finitely represented rules are finitary *)

  Fact rule_finite_t : soundly_represents -> finitely_represents -> forall c, finite_t (r c).
  Proof.
    intros Hf1 Hf2 c.
    destruct (Hf2 c) as (ll & Hll).
    exists (map (fun i => snd (f i)) (filter (fun i => if eqX_dec (fst (f i)) c then true else false) ll)).
    intros hs.
    rewrite in_map_iff.
    rewrite Hll.
    split; intros (i & H1 & H2); exists i.
    apply filter_In in H2.
    destruct H2 as (H2 & H3); split; auto.
    rewrite (surjective_pairing (f i)), H1.
    destruct (eqX_dec (fst (f i)) c).
    f_equal; auto.
    discriminate.
    split.
    rewrite H1; auto.
    apply filter_In.
    split; auto.
    rewrite H1; simpl.
    destruct (eqX_dec c c); auto.
  Qed.
  
  (* finitely represented rules can be reifed, ie it is possible to recover
     the parameter from the instance *)

  Fact rule_reif : finitely_represents -> forall c l, r c l -> { i | f i = (c,l) }.
  Proof.
    intros H c l.
    destruct (H c) as (ll & Hll).
    intros H1.
    rewrite Hll in H1.
    apply list_reif_dec in H1.
    destruct H1 as (i & ? & ?); exists i; auto.
    intro; decide equality.
    apply list_eq_dec.
    intros; apply eqX_dec.
  Qed.
  
  (* finitely represented rules are decidable *)

  Fact rule_dec : finitely_represents -> forall c l, { r c l } + { ~ r c l }.
  Proof.
    intros H c l.
    destruct (H c) as (ll & Hll).
    destruct in_dec with (a := (c,l)) (l := map f ll) as [ H1 | H1 ].
    intros; decide equality.
    apply list_eq_dec; intros; apply eqX_dec.
    left; apply Hll; apply in_map_iff in H1; auto.
    right; contradict H1; apply Hll in H1; apply in_map_iff; auto.
  Qed.
  
End representation_of_rules.
